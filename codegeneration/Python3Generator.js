const CodeGenerator = require('./CodeGenerator.js');

/**
 * This Visitor walks the tree generated by parsers and produces Python code.
 *
 * @returns {object}
 */
function Visitor() {
  CodeGenerator.call(this);

  return this;
}
Visitor.prototype = Object.create(CodeGenerator.prototype);
Visitor.prototype.constructor = Visitor;

// /////////////////////////// //
// Nodes that differ in syntax //
// /////////////////////////// //

/**
 * Visit String Literal
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitStringLiteral = function(ctx) {
  ctx.type = this.types.STRING;

  return this.singleQuoteStringify(this.visitChildren(ctx));
};

/**
 * Visit Property Name And Value List
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitPropertyNameAndValueList = function(ctx) {
  return this.visitChildren(ctx, {step: 2});
};

/**
 * Visit Property Expression Assignment
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitPropertyExpressionAssignment = function(ctx) {
  const key = this.singleQuoteStringify(this.visit(ctx.propertyName()));
  const value = this.visit(ctx.singleExpression());

  return `${key}: ${value}`;
};

/**
 * Because python doesn't need `New`, we can skip the first child
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitNewExpression = function(ctx) {
  const child = this.visitChildren(ctx, {start: 1});

  ctx.type = ctx.singleExpression().type;

  return child;
};

/**
 * Visit Object Literal
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitObjectLiteral = function(ctx) {
  ctx.type = this.types.OBJECT;

  return this.visitChildren(ctx);
};

/**
 * Visit Element List
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitElementList = function(ctx) {
  return this.visitChildren(ctx, {step: 2, separator: ', '});
};

/**
 * Visit Code Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitBSONCodeConstructor = function(ctx) {
  const args = ctx.arguments();

  if (
    args.argumentList() === null ||
    (
      args.argumentList().getChildCount() !== 1 &&
      args.argumentList().getChildCount() !== 3
    )
  ) {
    return 'Error: Code requires one or two arguments';
  }

  const argList = args.argumentList().singleExpression();
  const code = this.singleQuoteStringify(argList[0].getText());

  if (argList.length === 2) {
    /* NOTE: we have to visit the subtree first before type checking or type may
     not be set. We might have to just suck it up and do two passes, but maybe
     we can avoid it for now. */
    const scope = this.visit(argList[1]);

    if (argList[1].type !== this.types.OBJECT) {
      return 'Error: Code requires scope to be an object';
    }

    return `Code(${code}, ${scope})`;
  }

  return `Code(${code})`;
};

/**
 * This evaluates the code in a sandbox and gets the hex string out of the
 * ObjectId.
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitBSONObjectIdConstructor = function(ctx) {
  const args = ctx.arguments();

  if (args.argumentList() === null) {
    return 'ObjectId()';
  }

  if (args.argumentList().getChildCount() !== 1) {
    return 'Error: ObjectId requires zero or one argument';
  }

  let hexstr;

  try {
    hexstr = this.executeJavascript(ctx.getText()).toHexString();
  } catch (error) {
    return error.message;
  }

  return `ObjectId(${this.singleQuoteStringify(hexstr)})`;
};

/**
 * Visit Binary Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitBSONBinaryConstructor = function(ctx) {
  const args = ctx.arguments();
  let type = '';
  let binobj = {};
  const subtypes = {
    0: 'bson.binary.BINARY_SUBTYPE',
    1: 'bson.binary.FUNCTION_SUBTYPE',
    2: 'bson.binary.OLD_BINARY_SUBTYPE',
    3: 'bson.binary.OLD_UUID_SUBTYPE',
    4: 'bson.binary.UUID_SUBTYPE',
    5: 'bson.binary.MD5_SUBTYPE',
    6: 'bson.binary.CSHARP_LEGACY',
    128: 'bson.binary.USER_DEFINED_SUBTYPE'
  };

  if (
    args.argumentList() === null ||
    (
      args.argumentList().getChildCount() !== 1 &&
      args.argumentList().getChildCount() !== 3
    )
  ) {
    return 'Error: Binary requires one or two argument';
  }

  try {
    binobj = this.executeJavascript(ctx.getText());
    type = binobj.sub_type;
  } catch (error) {
    return error.message;
  }

  const argList = args.argumentList().singleExpression();
  const bytes = this.singleQuoteStringify(binobj.toString());

  if (argList.length === 1) {
    return `Binary(bytes(${bytes}, 'utf-8'))`;
  }

  return `Binary(bytes(${bytes}, 'utf-8'), ${subtypes[type]})`;
};

/**
 * Visit Double Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitBSONDoubleConstructor = function(ctx) {
  const args = ctx.arguments();

  if (
    args.argumentList() === null || args.argumentList().getChildCount() !== 1
  ) {
    return 'Error: Double requires one argument';
  }

  const arg = args.argumentList().singleExpression()[0];
  const double = this.removeQuotes(this.visit(arg));

  if (
    (arg.type !== this.types.STRING && this.isNumericType(arg) === false) ||
    isNaN(parseInt(double, 10))
  ) {
    return 'Error: Double requires a number or a string argument';
  }

  return `float(${double})`;
};

/**
 * Visit Long Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitBSONLongConstructor = function(ctx) {
  const args = ctx.arguments();

  if (
    args.argumentList() === null ||
    (
      args.argumentList().getChildCount() !== 1 &&
      args.argumentList().getChildCount() !== 3
    )
  ) {
    return 'Error: Long requires one or two argument';
  }

  let longstr = '';

  try {
    longstr = this.executeJavascript(ctx.getText()).toString();
  } catch (error) {
    return error.message;
  }

  return `Int64(${longstr})`;
};

/**
 * Visit Date Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitDateConstructorExpression = function(ctx) {
  const args = ctx.arguments();

  if (args.argumentList() === null) {
    return 'datetime.datetime.utcnow().date()';
  }

  let dateStr = '';

  try {
    const date = this.executeJavascript(ctx.getText());

    dateStr = [
      date.getUTCFullYear(),
      (date.getUTCMonth() + 1),
      date.getUTCDate(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds()
    ].join(', ');
  } catch (error) {
    return error.message;
  }

  return `datetime.datetime(${dateStr}, tzinfo=datetime.timezone.utc)`;
};

/**
 * Visit Date Now Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitDateNowConstructorExpression = function() {
  return 'datetime.datetime.utcnow()';
};

/**
 * Visit Number Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitNumberConstructorExpression = function(ctx) {
  const args = ctx.arguments();

  if (
    args.argumentList() === null || args.argumentList().getChildCount() !== 1
  ) {
    return 'Error: Number requires one argument';
  }

  const arg = args.argumentList().singleExpression()[0];
  const number = this.removeQuotes(this.visit(arg));

  if (
    (arg.type !== this.types.STRING && this.isNumericType(arg) === false) ||
    isNaN(parseInt(number, 10))
  ) {
    return 'Error: Number requires a number or a string argument';
  }

  return `int(${number})`;
};

/**
 * Visit MaxKey Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitBSONMaxKeyConstructor = function() {
  return 'MaxKey()';
};

/**
 * Visit MinKey Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitBSONMinKeyConstructor = function() {
  return 'MinKey()';
};

/**
 * Visit Symbol Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitBSONSymbolConstructor = function(ctx) {
  const args = ctx.arguments();

  if (
    args.argumentList() === null || args.argumentList().getChildCount() !== 1
  ) {
    return 'Error: Symbol requires one argument';
  }

  const arg = args.argumentList().singleExpression()[0];
  const symbol = this.visit(arg);

  if (arg.type !== this.types.STRING) {
    return 'Error: Symbol requires a string argument';
  }

  return `unicode(${symbol}, 'utf-8')`;
};

/**
 * Visit Object.create() Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitObjectCreateConstructorExpression = function(ctx) {
  const args = ctx.arguments();

  if (
    args.argumentList() === null || args.argumentList().getChildCount() !== 1
  ) {
    return 'Error: Object.create() requires one argument';
  }

  const arg = args.argumentList().singleExpression()[0];
  const obj = this.visit(arg);

  if (arg.type !== this.types.OBJECT) {
    return 'Error: Object.create() requires an object argument';
  }

  return obj;
};

/**
 * Visit Array Literal
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitArrayLiteral = function(ctx) {
  ctx.type = this.types.ARRAY;

  return this.visitChildren(ctx);
};

/**
 * Visit Undefined Literal
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitUndefinedLiteral = function(ctx) {
  ctx.type = this.types.UNDEFINED;

  return 'None';
};

/**
 * Visit Elision Literal
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitElision = function(ctx) {
  ctx.type = this.types.NULL;

  return 'None';
};

/**
 * Visit Null Literal
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitNullLiteral = function(ctx) {
  ctx.type = this.types.NULL;

  return 'None';
};

/**
 * Visit Octal Integer Literal
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitOctalIntegerLiteral = function(ctx) {
  ctx.type = this.types.OCTAL;

  let oct = this.visitChildren(ctx);
  let offset = 0;

  if (
    oct.charAt(0) === '0' &&
    (oct.charAt(1) === '0' || oct.charAt(1) === 'o' || oct.charAt(1) === 'O')
  ) {
    offset = 2;
  } else if (oct.charAt(0) === '0') {
    offset = 1;
  }

  oct = `0o${oct.substr(offset, oct.length - 1)}`;

  return oct;
};

/**
 * Visit BSON Timestamp Constructor
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitBSONTimestampConstructor = function(ctx) {
  const args = ctx.arguments();

  if (
    args.argumentList() === null || args.argumentList().getChildCount() !== 3
  ) {
    return 'Error: Timestamp requires two arguments';
  }

  const argList = args.argumentList().singleExpression();
  const low = this.visit(argList[0]);

  if (argList[0].type !== this.types.INTEGER) {
    return 'Error: Timestamp first argument requires integer arguments';
  }

  const high = this.visit(argList[1]);

  if (argList[1].type !== this.types.INTEGER) {
    return 'Error: Timestamp second argument requires integer arguments';
  }

  return `Timestamp(${low}, ${high})`;
};

/**
 * Visit Boolean Literal Literal
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitBooleanLiteral = function(ctx) {
  ctx.type = this.types.BOOL;

  const string = ctx.getText();

  return `${string.charAt(0).toUpperCase()}${string.slice(1)}`;
};

module.exports = Visitor;
